<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../responsive-utility/responsive-utility.html">
<link rel="import" href="../juicy-html/juicy-html.html">
<link rel="import" href="../web-animations-js/web-animations-next-lite.min.html">
<link rel="import" href="screenfull-lib.html">
<link rel="import" href="a11y-media-play-button.html">
<link rel="import" href="a11y-media-controls.html">
<link rel="import" href="a11y-media-transcript.html">

<!--
`a11y-media-player`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element
 - a standalone media player
 -
 -

-->

<dom-module id="a11y-media-player">
  <template>
    <style>
      :host {
        display: block;
        max-width: 100%;
        --paper-listbox-color: white;
        --paper-listbox-background-color: black;
        background-color: black;
      }
      :host #player-inner {
        z-index: 1;
      }
      :host #media {
        padding-top: 56.25%;
        position: relative;
      }
      :host #media,
      :host #media > *, 
      :host #slider,
      :host #controls {
        width: 100%;
      }
      :host #video {
        position: absolute;
        top: 0;
        left: 0;
      }
      :host #playbutton {
        padding-top: 56.25%;
        opacity: 1;
        -webkit-transition: opacity 0.5s;
        -moz-transition: opacity 0.5s;
        transition: opacity 0.5s;
      }
      :host #playbutton[disabled], 
      :host[playing] #playbutton {
        opacity: 0;
      }
      :host paper-toggle-button {
        --paper-toggle-button-unchecked-bar-color:  #eeeeee;
        --paper-toggle-button-unchecked-button-color:  #f8f8f8;
        --paper-toggle-button-checked-bar-color:  #00fffd;
        --paper-toggle-button-checked-button-color:  #00eeff;
      }
      :host paper-slider {
        z-index: 3;
        --paper-slider-knob-start-border-color: transparent;
        --paper-slider-knob-end-border-color: transparent;
        --paper-slider-active-color: #00fffd;
        --paper-slider-secondary-color: #4E7373;
        --paper-slider-pin-color: #444;
        --paper-slider-pin-start-color: #444;
        --paper-slider-knob-color: #00eeff;
        --paper-slider-knob-start-color: #eeeeee;
        --paper-slider-knob-end-color: #00eeff;
      }
    </style>
    <div id="player">
      <div id="player-inner">
        <div id="media">
          <video 
            autoplay$="[[autoplay]]" 
            id="video" 
            loop$="[[loop]]" 
            muted$="[[muted]]" 
            preload="metadata">
            <slot></slot>
            HTML5 video not supported 
          </video>
          <a11y-media-play-button id="playbutton"></a11y-media-play-button>
        </div>
      </div>
      <paper-slider id="slider" max$="[[duration]]" pin secondary-progress$="[[buffered]]" value$="[[elapsed]]"></paper-slider>
    </div>
    <a11y-media-controls 
      allow-fullscreen="[[allowFullscreen]]"
      autoplay="[[autoplay]]"
      cc="[[cc]]"
      fullscreen="[[fullscreen]]" 
      hide-ellapsed-time$="[[hideEllapsedTime]]"
      id="controls"
      length="[[__length]]"
      loop="[[loop]]"
      muted="[[muted]]"
      responsive-size="[[responsiveSize]]"
      playing="[[playing]]"
      playback-rate="[[playbackRate]]"
      volume="[[__volume]]">
    </a11y-media-controls>
  </template>

  <script>
    Polymer({

      is: 'a11y-media-player',

      listeners: {
        'controls-change': '_onControlsChanged',
        'play-button-clicked': 'play'
      },

      properties: {
        /** 
         * fullscreen option 
         */
        allowFullscreen: {
          type: Boolean,
          value: true,
        },
        /** 
         * autoplay is an option, 
         * but generally not recommended for a11y
         */ 
        autoplay: {
          type: Boolean,
          value: false,
        },
        /**
         * buffered video in seconds
         */
        buffered: {
          type: Number,
          value: 0,
        },
        /**
         * show closed captions
         */
        cc: {
          type: Boolean,
          value: false,
        },
        /**
         * duration of video in seconds
         */
        duration: {
          type: Number,
          value: 0,
        },
        /**
         * elapsed time in seconds
         */
        elapsed: {
          type: Number,
          value: 0,
        },
        /** 
         * is fullscreen mode
         */
        fullscreen: {
          type: Boolean,
          value: false,
        },
        /** 
         * The width of the media player. 
         */
        height: {
          type: String,
          value: 'unset'
        },
        /** 
         * hide elapsed time 
         */
        hideEllapsedTime: {
          type: Boolean,
          value: false,
        },
        /**
         * language
         */
        lang: {
          type: String,
          value: 'en',
          reflectToAttribute: true,
        },
        /**
         * length of video
         */
        length: {
          type: String,
          value: '',
        },
        /** 
         * looping is not fully supported
         */
        loop: {
          type: Boolean,
          value: false,
        },
        /** 
         * is audio muted
         */
        muted: {
          type: Boolean,
          value: false,
        },
        /**
         * size of the media element for responsive styling
         */
        responsiveSize: {
          type: String,
          notify: true,
          reflectToAttribute: true
        },
        /**
         * is media playing
         */
        playing: {
          type: String,
          value: false,
          reflectToAttribute: true
        },
        /**
         * playback rate where 1 is normal speed, 0.5 is half-speed, and 2 is double speed
         */
        playbackRate: {
          type: Number,
          value: 1
        },
        /** 
         * the transcript container. 
         */
        transcript: {
          type: Object,
          value: null,
        },
        /** 
         * Range is 0 to 100. Default should not be loud enough to overpower screen readers. 
         */
        volume: {
          type: Number,
          value: 70,
        },
        /** 
         * The width of the media player. 
         */
        width: {
          type: String,
          value: 'unset'
        },
      },
      /**
       * calls responsive-utility to get parent's responsive size
       */ 
      attached: function(){
        let root = this;
        Polymer.ResponsiveUtility.requestAvailability();
        root.fire('responsive-element',{
          "element": root,
          "attribute": "responsive-size",
          "relativeToParent": true
        });
      },
      ready: function(){
        let root = this, video = root.$.video, tracks = new Array();
        root.__slider = root.$.slider;
        root.__volume = root.muted ? 0 : Math.max(this.volume,10);
        root.__resumePlaying = false;
        root.__showFullscreen = this.allowFullscreen && screenfull.enabled;
        root.__length = 'Loading...';

        // handles fullscreen
        if(root.__showFullscreen) {
          screenfull.on('change', () => { this.fullscreen = screenfull.isFullscreen });
        }
        // handles dragging with a mouse
        root.$.slider.addEventListener('dragging-changed', (e) => {
          // when dragging stops, seeks to that value and 
          // if the video was playing before the dragging, resumes it
          if (!root.$.slider.dragging) { 
            root.seek(root.$.slider.immediateValue);
            root.__resumePlaying = false;
          }
        });
        // handles slider focus
        root.$.slider.addEventListener('focused-changed', (e) => {
          // temporarily pauses playback so that a value can be selected, 
          // but notes if playing should be resumed
          if(root.$.slider.focused){
            if (root.playing) root.__resumePlaying = true;
            root.pause();
          } else {
            root.seek(root.$.slider.value);
            root.__resumePlaying = false;
          }
        });
        //adjusts video width and height based on attributes
        if (root.width === 'unset' && root.height === 'unset'){
          root.style.width = '100%';  
        } else if (root.width === 'unset' && root.height !== 'unset') {
          root.style.height = root.height;
        } else {
          root.style.width = root.width;  
        }
        // handles loaded metadata
        video.addEventListener('loadedmetadata',function(){
          // adjusts aspect ratio
          if (root.width !== 'unset') root.setAttribute('width',root.width);
          if (root.height !== 'unset') root.setAttribute('width',root.height);
          let aspect = video.videoHeight/video.videoWidth * 100;
          root.$.playbutton.style.paddingTop = aspect+'%';
          root.$.media.style.paddingTop = aspect+'%';
          // gets and converts video duration
          root.duration = video.duration > 0 ? video.duration: 0; 
          root.__length = root._convertTime(0)+'/'+root._convertTime(video.duration);

          // hides the video subtitles and captions and adds them to the tracks dropdown-select
          if (video.textTracks.length > 0) root.selectTrack(0);
          
          // gets cues from tracks
          for(i in video.textTracks) {
            let cues = {};
            if (video.textTracks[i] !== null) {
              let text = video.textTracks[i].label !== undefined ? video.textTracks[i].label : video.textTracks[i].language;
              if(text !== undefined){
                let track = video.textTracks[i];
                root.setAttribute('has-captions',true);
                tracks.push({
                  'text': text, 
                  'language': track.language, 
                  'value': i
                });
                track.oncuechange = function(e){
                  if (root.transcript !== undefined && root.transcript !== null) {
                    root.transcript.activeCues = Object.keys(e.currentTarget.activeCues).map(function(key) { 
                      return e.currentTarget.activeCues[key].id;
                    });
                  }
                };
              }
            }
          }
          root.set('__tracks', tracks);
          if (root.transcript !== undefined && root.transcript !== null) {
            let complete = 0;
            for (var i=0 ; i < tracks.length; i++) {
              let itrack = tracks[i], track = video.textTracks[i], loaded = itrack.cues !== undefined;
              if(!loaded){
                track.mode = 'showing';
                let temp = setInterval(() => {
                  if (track.cues.length > 0) {
                    track.mode = 'hidden';
                    itrack.cues = Object.keys(track.cues).map(function(key) { 
                      return {
                        'order': Number(key),
                        'seek': track.cues[key].startTime,
                        'start': root._convertTime(track.cues[key].startTime),
                        'end': root._convertTime(track.cues[key].endTime), 
                        'text': track.cues[key].text
                      };
                    });
                    complete++;
                    if (complete === tracks.length && root.transcript !== null) {
                      root.transcript.setTracks(tracks);
                      root.transcript.setAttribute('selected-transcript',root.__selectedTrackId);
                    }
                    clearInterval(temp);
                  }
                },1);
              }
            }
          }
        });
        // when transcript is ready associate it with the player
        document.body.addEventListener('transcript-ready',function(e){
          if(root.getAttribute('id') === e.detail.mediaId) {
            root.transcript = e.detail;
            if (root.__tracks !== undefined) root.transcript.setTracks(tracks);
            root.transcript.addEventListener('cue-seek',function(e){
              root.seek(e.detail.cue.seek);
            });
          }
        });
      },
      /** 
       * plays the media 
       */
      play: function(e){
        let root = this, video = root.$.video;
        if (e === undefined || e.detail === root.$.playbutton) {
          root.$.playbutton.setAttribute('disabled',true);
          root.playing = true;
          // while playing, update the slider and length
          root.__playProgress = setInterval(() => {
            root.elapsed = video.currentTime > 0 ? video.currentTime : 0;
            root.__length = root._convertTime(video.currentTime,video.duration) +'/'+ root._convertTime(video.duration);
            // if the video reaches the end and is not set to loop, stop
            if(root.elapsed == root.duration && !root.loop){
              root.$.playbutton.removeAttribute('disabled');
              root.playing = false;
              clearInterval(root.__playProgress);
            }
            //updated buffered section of the slider
            root.buffered = video.buffered.length > 0 ? video.buffered.end(0) : root.elapsed;
          }, 1);

          root.$.video.play();
        }
      },
      /** 
       * pauses the media 
       */
      pause: function(){
        let root = this;
        root.playing = false;
        root.$.video.pause();
        clearInterval(root.__playProgress); //stops updating the slider and length
      },
      /** 
       * stops the media 
       */
      stop: function(){
        this.pause();
        this.seek(0);
      },
      /** 
       * restarts the media 
       */
      restart: function(){
        this.seek(0);
        this.play();
      },
      /** 
       * seeks media backward at a set increment
       */
      rewind: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.max(this.$.video.currentTime - amt,0));
      },
      /** 
       * seeks media forward at a set increment
       */
      forward: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.min(this.$.video.currentTime + amt,this.$.video.duration));
      },
      /** 
       * seeks to a specific time 
       */
      seek: function(time){
        let seekable = this.$.video.seekable;
        if (seekable.length > 0 && time >= seekable.start(0) && time <= seekable.end(0)) {
          this.$.video.currentTime = time;
          this.elapsed = time;
          this.__length = this._convertTime(this.$.video.currentTime,this.$.video.duration) +'/'+ this._convertTime(this.$.video.duration);
          if (this.__resumePlaying) this.play();
        }
      },
      /** 
       * selects a specific track by index
       */
      selectTrack: function(index){
        for(i in this.$.video.textTracks) {
          if (index == i) {
            this.$.video.textTracks[i].mode = 'showing';
            this.__selectedTrack = this.$.video.textTracks[i];
            this.__selectedTrackId = i;
          } else if (this.$.video.textTracks[i] !== null) {
            this.$.video.textTracks[i].mode = 'hidden';
          }
        }
        if (this.transcript !== null && this.transcript.tracks !== null) {
          this.transcript.setAttribute('selected-transcript',this.__selectedTrackId);
          //this.transcript.set('cues', this.__selectedTrack.cues);
        }
      },
      /** 
       * toggles captions:
       * toggleCC(true) to check the toggle, toggleCC(false) for unchecking, and toggleCC to toggle  
       */
      toggleCC: function(mode){
        mode = mode === undefined ? !this.cc : mode;
        this.cc = mode;
        if (this.__selectedTrack !== undefined && mode == true) {
          this.__selectedTrack.mode = 'showing';
          this.$.tracks.value = this.__selectedTrackId;
        } else if (this.__selectedTrack !== undefined) {
          this.__selectedTrack.mode = 'hidden';
          this.$.tracks.value = '';
        }
      },
      /** 
       * toggles mute:
       * toggleMute(true) to check the toggle, 
       * toggleMute(false) for unchecking, and 
       * toggleMute to toggle  
       */
      toggleMute: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.muted = mode;
        this.__volume = this.muted ? 0 : Math.max(this.volume,10);
        this.$.video.volume = this.muted ? 0 : Math.max(this.volume/100,0.1);
        this.$.video.muted = this.muted;
      },
      /** 
       * toggles autoplay:
       * toggleAutoplay(true) to check the toggle, 
       * toggleAutoplay(false) for unchecking, and 
       * toggleAutoplay to toggle  
       */
      toggleAutoplay: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.autoplay = mode;
      },
      /** 
       * set volume of media
       */
      setVolume: function(value){
        this.volume = value !== null ? value : 70;
        this.$.video.volume = this.volume !== null ? value/100 : 0.7;
        this.muted = value === null || value === 0;
      },
      /** 
       * set speed/playback rate of media
       */
      setPlaybackRate: function(value){
        this.$.video.playbackRate = value !== null ? value : 1;
      },
      /** 
       * toggles looping:
       * toggleLoop(true) to check the toggle, toggleLoop(false) for unchecking, and toggleLoop to toggle  
       */
      toggleLoop: function(mode){
        mode = mode === undefined ? !this.loop : mode;
        this.loop = mode;
        this.$.video.muted = this.loop;
      },
      /**
       * set play/pause button 
       */
      _convertTime: function(val,max){
        max = max === undefined ? val : max;
        let a = (val) => { return val < 10 ? '0' + val : val; }, 
        b = (val,i) => { return Math.floor(max/i) > 0 ? a(Math.floor(val/i)) : '00' },
        c = (val) => { return val < 100 ? val+'0' : val };
        d = (val) => { return Math.floor(max/3600) > 0 ? a(Math.round(val)) : a(Math.floor(val))+'.'+c(a(Math.round(val*10))) };
        return b(val,3600)+':'+b(val%3600,60)+':'+d(val%60);
      },
      /**
       * determine which button was clicked and act accordingly 
       */
       _onControlsChanged: function(e){
        let action = e.detail.label !== undefined ? e.detail.label : e.detail.id;
        if (action === 'backward') {
          this.rewind(this.$.video.duration/20);
        } else if (action === 'closed captions' || action === 'captions') {
          this.toggleCC();
        } else if (action === 'forward') {
          this.forward(this.$.video.duration/20);
        } else if (action === 'full screen') {
          screenfull.toggle(this);
        } else if (action === 'loop') {
          this.toggleLoop();
        } else if (action === 'mute' || action === 'unmute') {
          this.toggleMute();
        } else if (action === 'pause') {
          this.pause();
        } else if (action === 'play') {
          this.play();
        } else if (action === 'restart') {
          this.seek(0);
          this.play();
        } else if (action === 'speed') {
          this.setPlaybackRate(e.detail.value);
        } else if (action === 'volume') {
          this.setVolume(e.detail.value);
        }
      }
    });
  </script>
</dom-module>
